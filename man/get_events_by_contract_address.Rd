% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_events_by_contract_address.R
\name{get_events_by_contract_address}
\alias{get_events_by_contract_address}
\title{Get events by contract address}
\usage{
get_events_by_contract_address(
  address,
  event_name = NULL,
  block_number = NULL,
  only_confirmed = NULL,
  only_unconfirmed = NULL,
  min_timestamp = 0,
  max_timestamp,
  direction = "desc",
  limit = 100L,
  max_attempts = 3L
)
}
\arguments{
\item{address}{(character) - address of the smart contract of interest, in
\code{base58} (starts with \code{T}) or \code{hex} (starts with \code{41}) format.}

\item{event_name}{(character) - name of the specific event of interest
(e.g., \code{Transfer}). Defaults to \code{NULL}.}

\item{block_number}{(character) - block number to look within. Defaults to
\code{NULL}.}

\item{only_confirmed}{(boolean or \code{NULL}) - if \code{NULL} (default) or \code{FALSE},
the result is returned irrespective of whether the event's
parent transaction is confirmed. If \code{TRUE}, only results for confirmed
transactions are returned. Cannot be used simultanously with
the \code{only_unconfirmed} argument.}

\item{only_unconfirmed}{(boolean or \code{NULL}) - if \code{NULL} (default) or \code{FALSE},
the result is returned irrespective of whether the respective event's
parent transaction is confirmed. If \code{TRUE}, only unconfirmed transactions
are returned. Cannot be used simultanously with the \code{only_confirmed}
argument.}

\item{min_timestamp}{(numeric or character) - a Unix timestamp
(\emph{including milliseconds}), which defines the beginning of the
period to retrieve the events from. Defaults to 0.}

\item{max_timestamp}{(numeric or character) - a Unix timestamp
(\emph{including milliseconds}), which defines the end of the
period to retrieve the events from.}

\item{direction}{(character) - specifies the direction of temporal ordering
of the results - descending (\code{desc}) or ascending (\code{asc}).}

\item{limit}{(integer) - number of transactions per page. Defaults to 200.
Maximum accepted value is 200 (higher values will be ignored).}

\item{max_attempts}{(integer, positive) - specifies the maximum
number of additional attempts to call the API if the first attempt fails
(i.e. its call status is different from \code{200}). Additional attempts are
implemented with an exponential backoff. Defaults to 3.}
}
\value{
A nested tibble where each row corresponds to an event associated
with the transaction of interest. This tibble contains the following
columns:
\itemize{
\item \code{tx_id} (character) - same as the argument \code{tx_id};
\item \code{block_number} (character);
\item \code{block_timestamp} (POSIXct, UTC timezone);
\item \code{contract_address} (character) adress of the contract that performed the
transaction of interest;
\code{event_name} (character) - possible values of this column will depend on
the nature of the transaction of interest;
\code{event_data} (list) - each element of this list contains a tibble with
additional attributes of the event.
}

If no events are found for the specified combinations of query
parameters, nothing (\code{NULL}) is returned, with a console message
\code{"No events found"}.
}
\description{
Retrieves events associated with a smart contract
}
\details{
The exact content of \code{event_data} in the returned result will
be contract- and event-specific. Thus, very little processing is done with
these data, except for removing redundant attributes and converting all
addresses to \code{base58} format.
}
\examples{
address <- "TKttnV3FSY1iEoAwB4N52WK2DxdV94KpSd"
min_timestamp <- "1576317786000"
max_timestamp <- "1576317996000"
get_events_by_contract_address(address = address,
                               min_timestamp = min_timestamp,
                               max_timestamp = max_timestamp)
get_events_by_contract_address(address = address,
                               min_timestamp = min_timestamp,
                               max_timestamp = max_timestamp,
                               event_name = "Transfer",
                               direction = "asc")


}
